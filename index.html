<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Asta's Omni-Sorcerer OS</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  
  <style>
    body { background: #000; margin: 0; overflow: hidden; font-family: 'Courier New', monospace; }
    canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; transform: scaleX(-1); }
    
    #hud {
      position: absolute; top: 20px; left: 20px; color: #00ffcc; z-index: 100;
      background: rgba(0, 10, 20, 0.8); padding: 15px; border: 1px solid #00ffcc;
      border-radius: 5px; pointer-events: none;
    }
    .key { color: orange; font-weight: bold; }
    
    #init-btn {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      padding: 20px 40px; background: orange; border: none; font-size: 20px;
      font-weight: bold; cursor: pointer; z-index: 200; box-shadow: 0 0 30px orange;
    }
  </style>
</head>
<body>

  <button id="init-btn" onclick="initSystem()">INITIALIZE OMNI-SYSTEM</button>

  <div id="hud">
    <h3>COMMAND LIST</h3>
    <p><span class="key">‚òù Index:</span> Draw Light</p>
    <p><span class="key">‚úä Fist:</span> Shatter/Clear</p>
    <p><span class="key">üëå Pinch:</span> Time Stone</p>
    <p><span class="key">üëê Merge:</span> Singularity</p>
    <p>Status: <span id="status">Standby</span></p>
  </div>

  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusText = document.getElementById('status');
    let width, height;
    
    // --- STATE VARIABLES ---
    let time = 0;
    let strokes = []; // For Drawing
    let currentStroke = [];
    let particles = [];
    let fusionEnergy = 0;
    let audioCtx, oscHum, gainHum;

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- AUDIO SYSTEM ---
    function initSystem() {
      document.getElementById('init-btn').style.display = 'none';
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      
      // Background Drone
      oscHum = audioCtx.createOscillator();
      gainHum = audioCtx.createGain();
      oscHum.connect(gainHum);
      gainHum.connect(audioCtx.destination);
      oscHum.frequency.value = 60;
      gainHum.gain.value = 0.05;
      oscHum.start();
    }

    function updateSound(activityLevel) {
      if(!audioCtx) return;
      // Pitch rises with activity
      oscHum.frequency.setTargetAtTime(60 + activityLevel, audioCtx.currentTime, 0.1);
    }

    // --- PARTICLE CLASS ---
    class Particle {
      constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        this.vx = (Math.random() - 0.5) * 5;
        this.vy = (Math.random() - 0.5) * 5;
        this.life = 1.0;
      }
      update() {
        this.x += this.vx; this.y += this.vy;
        this.vy += 0.2; // Gravity
        this.life -= 0.04;
      }
      draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;
      }
    }

    // --- GEOMETRY DRAWING ---
    function drawMandala(x, y, color, speed) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(time * speed);
      ctx.strokeStyle = color;
      ctx.shadowBlur = 15;
      ctx.shadowColor = color;
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0, 0, 60, 0, Math.PI*2); ctx.stroke();
      ctx.strokeRect(-40, -40, 80, 80);
      ctx.rotate(Math.PI/4); ctx.strokeRect(-40, -40, 80, 80);
      ctx.restore();
    }

    // --- MAIN LOOP ---
    function onResults(results) {
      // 1. Motion Blur Background
      ctx.fillStyle = "rgba(0, 5, 10, 0.2)";
      ctx.fillRect(0, 0, width, height);
      
      // 2. Draw User Video
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.drawImage(results.image, 0, 0, width, height);
      ctx.restore();

      // 3. Draw Persistent Lines (Architect Mode)
      ctx.globalCompositeOperation = "lighter";
      ctx.lineWidth = 3;
      ctx.shadowBlur = 10;
      ctx.shadowColor = "cyan";
      ctx.strokeStyle = "cyan";
      strokes.forEach(stroke => {
        ctx.beginPath();
        stroke.forEach((p, i) => { if(i==0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
        ctx.stroke();
      });
      // Draw current stroke
      if(currentStroke.length > 1) {
         ctx.strokeStyle = "white";
         ctx.beginPath();
         currentStroke.forEach((p, i) => { if(i==0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
         ctx.stroke();
      }

      let activeHands = 0;
      let hands = results.multiHandLandmarks;

      if (hands && hands.length > 0) {
        // --- FUSION CHECK (Are hands close?) ---
        let isFused = false;
        if (hands.length === 2) {
          const d = Math.hypot(hands[0][9].x - hands[1][9].x, hands[0][9].y - hands[1][9].y);
          if (d < 0.15) {
             isFused = true;
             fusionEnergy = Math.min(fusionEnergy + 5, 150);
             const cx = (hands[0][9].x + hands[1][9].x) * 0.5 * width;
             const cy = (hands[0][9].y + hands[1][9].y) * 0.5 * height;
             
             // Draw Singularity
             ctx.fillStyle = "white";
             ctx.shadowColor = "purple";
             ctx.shadowBlur = fusionEnergy;
             ctx.beginPath(); ctx.arc(cx, cy, fusionEnergy/3, 0, Math.PI*2); ctx.fill();
             statusText.innerText = "SINGULARITY DETECTED";
             
             // Spawn Void Particles
             particles.push(new Particle(cx, cy, "violet"));
          } else {
             fusionEnergy = Math.max(fusionEnergy - 5, 0);
          }
        }

        // --- INDIVIDUAL HAND LOGIC ---
        if (!isFused) {
          hands.forEach(lm => {
             const x = lm[9].x * width;
             const y = lm[9].y * height;
             const idxTip = lm[8];
             const ix = idxTip.x * width;
             const iy = idxTip.y * height;

             // Gesture Logic
             const indexUp = lm[8].y < lm[6].y;
             const middleDown = lm[12].y > lm[10].y;
             const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
             const isPinch = pinchDist < 0.05;
             const isFist = middleDown && indexUp === false; // Rough fist check

             if (isFist) {
               // CLEAR
               statusText.innerText = "SHATTER";
               if(strokes.length > 0) strokes = []; 
               ctx.strokeStyle = "red"; ctx.beginPath(); ctx.arc(x, y, 50, 0, Math.PI*2); ctx.stroke();
             } 
             else if (indexUp && middleDown && !isPinch) {
               // DRAW
               statusText.innerText = "DRAWING";
               currentStroke.push({x: ix, y: iy});
               ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(ix, iy, 5, 0, Math.PI*2); ctx.fill();
             } 
             else if (isPinch) {
               // TIME STONE
               statusText.innerText = "TIME MANIPULATION";
               if(currentStroke.length > 0) { strokes.push(currentStroke); currentStroke = []; }
               drawMandala(x, y, "#00ff00", -0.05); // Green, reverse spin
               particles.push(new Particle(x, y, "#00ff00"));
             } 
             else {
               // DEFAULT SHIELD
               statusText.innerText = "SHIELD ACTIVE";
               if(currentStroke.length > 0) { strokes.push(currentStroke); currentStroke = []; }
               drawMandala(x, y, "orange", 0.02);
             }
          });
        }
      }

      // Update Particles
      particles.forEach((p, i) => {
         p.update(); p.draw(ctx);
         if(p.life <= 0) particles.splice(i, 1);
      });
      
      updateSound(fusionEnergy);
      time++;
      ctx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const camera = new Camera(videoElement = document.createElement('video'), {
      onFrame: async () => { await hands.send({image: videoElement}); },
      width: 1280, height: 720
    });
    camera.start();
  </script>
</body>
</html>
